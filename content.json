{"meta":{"title":"一共十七划","subtitle":"Noir","description":"我们逃去看海吧","author":"Noir","url":"https://noirzh.github.io","root":"/"},"pages":[{"title":"关于","date":"2023-11-12T02:09:05.480Z","updated":"2023-11-12T02:09:05.480Z","comments":false,"path":"about/index.html","permalink":"https://noirzh.github.io/about/index.html","excerpt":"","text":"代码苦手,建模苦手,破铜烂铁收集者 会将一些自己觉得有趣的学习内容放在这里 希望能帮到你"},{"title":"分类","date":"2023-11-11T07:21:08.752Z","updated":"2023-11-11T07:21:08.752Z","comments":false,"path":"categories/index.html","permalink":"https://noirzh.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-11-11T07:21:08.753Z","updated":"2023-11-11T07:21:08.753Z","comments":true,"path":"links/index.html","permalink":"https://noirzh.github.io/links/index.html","excerpt":"","text":""},{"title":"书单","date":"2023-11-11T07:21:08.752Z","updated":"2023-11-11T07:21:08.752Z","comments":false,"path":"books/index.html","permalink":"https://noirzh.github.io/books/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2023-11-11T07:21:08.754Z","updated":"2023-11-11T07:21:08.754Z","comments":false,"path":"repository/index.html","permalink":"https://noirzh.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-11-11T07:21:08.754Z","updated":"2023-11-11T07:21:08.754Z","comments":false,"path":"tags/index.html","permalink":"https://noirzh.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"markdown排版效果","slug":"My-New-Post","date":"2023-11-11T07:24:50.000Z","updated":"2023-11-12T06:20:30.957Z","comments":true,"path":"2023/11/11/My-New-Post/","permalink":"https://noirzh.github.io/2023/11/11/My-New-Post/","excerpt":"","text":"来自这里 基础部分 typora能够实时渲染,所以记得开源代码显示器 标题 这个我不用多说吧 段落 除了这个回车之外 还有这个 换行或者shift+entet我 我 我 风格 以下代码能够实现换行,大概,放在最后一行 p{text-indent:2em} 分割线 这样或者 这样 项 无序项 及其连环套 简单吧 有序 同理 项 引用 引用 和交叉引用 很简单 对吧 层数 强调 包括加粗和斜体甚至可以这样 辅助线 删除和下划线 字体 使用 &lt;font&gt; 标签的修改字体 这里是默认字体 这里是黑体 这里是楷体 这里是扩展字体 p {font-size: 2rem;} 使用 &lt;font&gt; 标签的修改字号 这里是默认正文字号 1号字 最小 2号字 3号字 默认 4号字 5号字 6号字 7号字 最大 前景色和背景色 使用 &lt;font&gt; 的标签的修改文字前景色 红色 绿色 蓝色 使用 rgb 颜色值 使用十六进制颜色值 使用 style 属性修改文字的背景色 红色 绿色 蓝色 使用 rgb 颜色值 使用十六进制颜色值 更丰富背景样式 I wish you a Merry Christmas 使用图片作背景 太阳太阳，给我们带来，七色光彩 渐变背景色 行内代码和代码块 定义行内代码 行内的 html 代码：&lt;head&gt;&lt;title&gt;网页标题&lt;/title&gt;&lt;/head&gt; 行内的 json 代码：var json = {key: value}; 使用反引号定义代码块 123pubic static void main(String[] args) { System.out.println(\"Hello world\");} 超链接 声明超链接 一对中括号就可以将文字转换为超链接，如: 北京，上海，广州，深圳 声明超链接的细节 声明超链接的细节 天坛公园，是明清两代皇帝每年祭天和祈祷五谷丰收的地方。天坛以严谨的建筑布局、奇特的建筑构造和瑰丽的建筑装饰著称于世。 图片 使用全局声明方式插入图片 ![][img2] ![][img2] img { border-radius: 50% !important; border: 30px solid #eee; } 拓展 此时很多东西就需要有相应插件了,自己查看 任务列表 在 Markdown 文件中，在 \" 无序列表 -,+,* \" 后面使用 「中括号 []」 声明复选框。在中括号中写入 x ，便可实现选中效果。 就像是 复选框 checkbox Java Php 转义 在文档中使用特殊字符 如果不使用转义字符，以下算式将不能按预期输出 234=24 以上算式的正确写法为： 2*3*4=24 注释 基于 HTML 样式 这是一段被注释掉的文字 这是一段没有被注释的文字 通过 Markdown 解析达到注释效果 这是一段没有被注释的文字 表格 Markdown 表格包含三个部分：表头、分割线、数据。 表头 用来对列名对象进行描述，也就是通常所说的列名； 数据 用来展示每行的具体内容，数据是表格的核心； 分割线 用来区分表头和数据，也是 Markdown 中表格定义的最基本语法要求。 表格内容的对齐 左对齐 居中对齐 右对齐 1 张三 17岁 2 李四 18岁 3 王五 19岁 流程图 纵向 12graph TD 开始 --&gt; 结束 横向 12graph LR 开始 --&gt; 结束 名字和内容分开 1234graph LR 一号节点[在此输入希望在一号节点上显示的文字内容] 二号节点[如常] 一号节点 --&gt; 二号节点 特殊形状 123456789graph TD 圆((节点显示文本)) 这种&gt;也可以] 长方形[或者] 这个{菱形} 我{{六角形}} 平行四边形[/这个/] 或者这种[\\难以理解的脑洞/] 连接线 一般的 12345graph LR A --- B -- 带文字连接线 --- C B --&gt; A C -.-&gt; D E -.带文字也可以.-&gt; f ==&gt; A ==一样的 ==&gt; C 更高级的 1234567891011graph TB c1--&gt;a2 subgraph 第一组 a1--&gt;a2 end subgraph 第二组 b1--&gt;b2 end subgraph 第三组 c1--&gt;c2 end 时序图 类型 描述 -&gt; 没有箭头的实线 –&gt; 没有箭头的虚线 -&gt;&gt; 有箭头的实线 --&gt;&gt; 有箭头的虚线 -x 有交叉箭头的实线 –x 有交叉箭头的虚线 123sequenceDiagram 李雷 -&gt;韩梅梅: Hi LiLei, How do you do? 韩梅梅--&gt;&gt;李雷: How do you do! 别名 123456sequenceDiagram participant l as 李雷 participant h as 韩梅梅 l-&gt;&gt;h: Hello Hanmeimei, how are you? h-&gt;&gt;l: Hello Lilei, I am fine, thank you, and you? l--&gt;h: I am fine, thank you. 添加备注 1234sequenceDiagram 李雷-&gt;&gt;韩梅梅: Hi Hanmeimei, How do you do? Note over 李雷,韩梅梅: Lesson 1 韩梅梅--&gt;&gt;李雷: How do you do! 聚焦和另一种备注 12345678910sequenceDiagram participant l as 李雷 participant h as 韩梅梅 l-&gt;&gt;h: Hello, what's your name? activate h h--&gt;&gt;l: Hello, my name is Hanmeimei! deactivate h Note left of l : test l-&gt;&gt;+h:yeah h-&gt;&gt;-l :great 逻辑 12345678910111213141516sequenceDiagram participant l as 李雷 participant h as 韩梅梅 l -&gt;&gt; h: Hello, what's your name? loop test 听到与否 opt 听到了吗 l-&gt;&gt;h:can you hear me? alt yes h-&gt;&gt;l: yeah else no h-&gt;&gt;l: what end end end h -&gt;&gt; l :great 类图 包括用class或者关系声明类,用冒号声明类成员 1234567classDiagram class 动物 class 我 动物 : 吃() 动物 : 我 我 --|&gt; 动物 我:另一个 更多声明 12345678910111213141516classDiagram class 银行账户 { +String 户主 +BigDecimal 余额 +存(数量)* bool +取(数量)- int } classA --|&gt; classB : 继承 classC --* classD : 组成 classE --o classF : 集合 classG --&gt; classH : 关联 classI -- classJ : 实线连接 classK ..&gt; classL : 依赖 classM ..|&gt; classN : 实现 classO .. classP : 虚线连接 状态图 使用 &lt;&lt;fork&gt;&gt; 描述分支，使用 &lt;&lt;join&gt;&gt; 描述聚合。 12345678910111213141516171819202122232425stateDiagram [*] --&gt; 下单成功 下单成功 --&gt; 备货 state 出货中 &lt;&lt;fork&gt;&gt; 备货 --&gt; 出货中 出货中 --&gt; 出货失败 出货失败 --&gt; [*] 出货中 --&gt; 出货确认 state 出货确认{ 出货中 --&gt; NumLock关 NumLock关 --&gt; NumLock开 : 按下 NumLock 键 NumLock开 --&gt; NumLock关 : 按下 NumLock 键 -- 出货中 --&gt; CapsLock关 CapsLock关 --&gt; CapsLock开 : 按下 CapsLock 键 CapsLock开 --&gt; CapsLock关 : 按下 CapsLock 键 -- [*] --&gt; ScrollLock关 ScrollLock关 --&gt; ScrollLock开 : 按下 ScrollLock 键 ScrollLock开 --&gt; ScrollLock关 : 按下 ScrollLock 键 } 出货确认 --&gt; 出货完毕 出货完毕 --&gt; 订单完成 订单完成 --&gt; [*] 甘特图 123456789101112131415161718192021222324252627gantt dateFormat :YYYY-MM-DD title :甘特图实例 section 基本任务 已完成任务 :done, des1, 2014-01-06,2014-01-08 进行中任务 :active, des2, 2014-01-09, 3d 未开始任务1 : des3, after des2, 5d 未开始任务2 : des4, after des3, 5d section 紧急任务 已完成的紧急任务 :crit, done, 2014-01-06,24h 已完成紧急任务1 :crit, done, after des1, 2d 进行中紧急任务2 :crit, active, 3d 未开始紧急任务3 :crit, 5d 未开始一般任务4 :2d 未开始一般任务5 :1d section 文档编写 进行中文档任务1 :active, a1, after des1, 3d 未开始文档任务2 :after a1 , 20h 未开始文档任务3 :doc1, after a1 , 48h section 其他部分 其他任务1 :after doc1, 3d 其他任务2 :20h 其他任务3 :48h 饼图 1234pie title 宠物的选择 \"狗\" : 386 \"猫\" : 185 \"兔子\" : 15 上下标 如题不难但是test这个方式实际上不兼容 有一个更实用的HTML abcd 数学公式 最基本的是这个,将等式包裹在$$里面 四则 加法符号： 减法符号： 加减符号： 减加符号： 叉乘符号： 点乘符号： 星乘符号： 除法符号： 斜除符号： 分式1 ： 分式2 ： 绝对值： 逻辑运算 等于符号： 大于符号： 小于符号： 大于等于符号： 小于等于符号： 不等于符号： 不大于等于符号： 不大于等于符号： 不小于等于符号： 不小于等于符号： 约等于符号： 恒定等于符号： 高级运算 平均数符号： 开二次方符号： 开方符号： 对数符号： 极限符号： 极限符号： 求和符号： 求和符号： 积分符号： 积分符号： 微分符号：\\partial，如： 矩阵符号： 公式里的上下标 上标符号： 下标符号： 组合符号： 希腊字母 阿尔法：， 贝塔：， 伽玛：， 德尔塔：， 艾普西龙：， 捷塔：， 依塔：， 西塔：， 艾欧塔：， 喀帕：， 拉姆达：， 缪：， 拗：， 克西：， 欧麦克轮：， 派：， 柔：， 西格玛：， 套：， 宇普西龙：， 发艾：， 器：， 普赛：， 欧米伽：， 脚注 这里有一个脚注1。 这里有一个脚注2。 test 这里主要测数学公式 此处是 脚注 的 文本内容。↩︎ 对吧↩︎","categories":[],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://noirzh.github.io/tags/markdown/"}]},{"title":"A=B 第三章题解","slug":"第三章","date":"2023-11-09T15:04:20.000Z","updated":"2023-11-11T08:49:46.752Z","comments":true,"path":"2023/11/09/第三章/","permalink":"https://noirzh.github.io/2023/11/09/%E7%AC%AC%E4%B8%89%E7%AB%A0/","excerpt":"","text":"前言 这个关键字相当于在找到特定的子字符串之后,删去该子字符串,并且将我们指定的新字符串插入到原字符串的开头与结尾 类似于正则表达式的^与$的应用 很像是我们在第二章的操作:将字母压之后换成其他字母往后排以使得压缩持续进行 3-1 去除 相当简单的教程 12(start)a=(end)a= 3-2 旋转 这里只针对前面不是a进行操作,可以保证 12(start)b=(end)b(start)c=(end)c 3-3 A到B 2 思路 开始上难度了,但是其实不难,我们只需要先把所有特定位置的a变成特殊的,然后再处理另一边的特殊的即可 就像是我们之前做过的一样,此时的代码如下 123456(start)a=xxa=ax(end)a=zaz=zax=bz=b 优化 我们很容易注意到我们的xa=ax或者之类的操作只是把所有符合要求的串找出来,保证不阻塞生成 于是我们注意到移到另一边的位置显然更好(指行数更小),更新之后如下 代码 1234(start)a=(end)x(end)x=(start)b(end)a=(start)x(start)x=(end)b 3-5 首尾 通过上一题我们就知道弄到尾部直接判断即可 我们唯一要注意的就是判断在前,不然容易出死循环 123456789ax=(return)true #有任意一个就是真的,能迅速检查到by=(return)truecz=(return)true#以下的操作会1.在有相同的时候把除了最后一个字母之外都换成其他字母插入到后面 2.没有相同的时候所有都插入到后面(start)a=(end)x(start)b=(end)y(start)c=(end)z=(return)false 3-6 最多 2 思路 与之前的类似,但是我们需要保留所有作比较的字母来保证恢复,然后这里其实就可以 123456789101112131415ca=accb=bcba=abab=(end)xcx=(end)y #y代表abc,可随时换成最多的 #剩下ac和bc#之后我们不用关心y具体是什么,只要二者消耗,剩下的那个做全员回复就行ac=(end)ybc=(end)y#做一个穷举ax=aacy=ccby=bbay=aabx=bb 优化 发现ax,ay的行为是相同的,bx,by也是,优化以下 12345678910111213ca=accb=bcba=abab=(end)xcx=(end)y #y代表abc,可随时换成最多的#acy bcy ay by cy ac=(end)ybc=(end)yx=ycy=ccby=bbay=a 3-7回文串 思路 判断是不是消除之后全空即可,如3-5的加强版,我们进行全局替换,然后穷举非空情况,但是注意我们不用考虑剩下来的单个字母的情况,因为那种情况也属于回文串 12345678910111213cz=by=ax=(start)a=(end)x(start)b=(end)y(start)c=(end)zxy=(return)falsexz=(return)falseyx=(return)falseyz=(return)falsezx=(return)falsezy=(return)false=(return)true 挑战优化 注意到我们六行代码目的都只是为了判断是否有两个字母及以上存在 修改字符串使之存在首尾标识符即可,也就是说能保证显示出来两个字母不同且存在 12345678cuZn=buYn=auXn=(start)a=(end)uXn(start)b=(end)uYn #不影响排空(start)c=(end)uZnnu=(return)false #出现这个说明仍有多个字母存在,整个字符串非空,=(return)true","categories":[],"tags":[{"name":"A=B","slug":"A-B","permalink":"https://noirzh.github.io/tags/A-B/"}]},{"title":"题解-逃离火灾-两遍BFS","slug":"题解-逃离火灾","date":"2023-11-09T00:04:17.000Z","updated":"2023-11-12T06:59:21.770Z","comments":true,"path":"2023/11/09/题解-逃离火灾/","permalink":"https://noirzh.github.io/2023/11/09/%E9%A2%98%E8%A7%A3-%E9%80%83%E7%A6%BB%E7%81%AB%E7%81%BE/","excerpt":"","text":"Problem: 2258. 逃离火灾 [TOC] 思路 由题意可知需要计算一条最短路,耗时最短以保证后续火传过来的时候让火传递的时间足够长来接近答案 火的蔓延时间用DFS求解,可以求出来火到各个节点的最少用时 应该考虑每次刷新一下出发时间来看此次最短路是否被烧掉吗?其实不用 只需要考虑在终点人能否比火早到即可 假如人在路上遇到火,则火到终点的用时一定小于等于人 保证了到终点的时候火耗时大于人可以反推出 人和火相遇的路都能保证有如此长的等待时间 若人和火不相遇则显然 ## 细节 如果起点起火不可达 对于只有人可达的情况,是等待多久都可以的情况 重点:因为允许人和火同时进安全屋,但是不能要求其他格子里人和火同时到 考虑将终点旁边的两格当做终点,如果他们到达终点所剩下的时间大于等于1,显然可以在外面等一分钟 解题方法 两遍BFS求火和人到各个节点的距离 对于起点和终点的几种情况特判 查询以终点左边和上边的点是否允许多等一分钟 返回答案 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Solution: def maximumMinutes(self, grid: List[List[int]]) -&gt; int: n=len(grid[0]) m=len(grid) times=[[0x7fffffff]*n for _ in range(m)] q=deque() directions=[[0,-1],[0,1],[1,0],[-1,0]] for i in range(m): for j in range(n): if grid[i][j]==1: q.append([i,j]) elif grid[i][j]==2: times[i][j]=-1#不可达 now=0 h=set() while q: length=len(q) for _ in range(length): i,j=q.popleft() times[i][j]=now h.add((i,j)) for dx,dy in directions: x,y=i+dx,j+dy if 0&lt;=x&lt;m and 0&lt;=y&lt;n and grid[x][y]!=2 and (x,y) not in h: q.append((x,y)) now+=1 #然后我们求人到各个节点用时 people=[[0x7fffffff]*n for _ in range(m)] q.append((0,0)) h.clear() now=0 h=set() while q: length=len(q) for _ in range(length): i,j=q.popleft() people[i][j]=now h.add((i,j)) for dx,dy in directions: x,y=i+dx,j+dy if 0&lt;=x&lt;m and 0&lt;=y&lt;n and grid[x][y]!=2 and grid[x][y]!=1 and (x,y) not in h: q.append((x,y)) now+=1 if times[-1][-1]&lt;people[-1][-1] or people[-1][-1]==0x7fffffff: return -1 if times[0][0]==0: return -1 if times[-1][-1]==0x7fffffff: return 1000000000#火不可达,说明人到火这一路都没有火 maxNeed=times[-1][-1]-people[-1][-1] if times[-1][-2]&gt;people[-1][-2]+maxNeed or times[-2][-1]&gt;people[-2][-1]+maxNeed: return maxNeed return maxNeed-1","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://noirzh.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"Python","slug":"Python","permalink":"https://noirzh.github.io/tags/Python/"},{"name":"BFS","slug":"BFS","permalink":"https://noirzh.github.io/tags/BFS/"}]},{"title":"A=B 第二章题解","slug":"第二章","date":"2023-11-07T07:24:50.000Z","updated":"2023-11-11T08:48:45.921Z","comments":true,"path":"2023/11/07/第二章/","permalink":"https://noirzh.github.io/2023/11/07/%E7%AC%AC%E4%BA%8C%E7%AB%A0/","excerpt":"","text":"前言 我们要好好理解一下a=(return)b干了啥: 找到匹配的字符串a 将整个我们的字符串变成b 中断循环,看结果 换成函数表达就是 123if a in s: s=b return s 之后判题的只能看到你返回的字符串b 2.1 你好世界 这里给出来了一个提示,在我们用空等的时候 1=(return)helloworld 2.2 AAA 思路 我们需要看a的数量,也就是说我们不用管b,c,将二者全消除之后剩下的就是a,再看其是否大于等于3个即可 代码 1234b=c=aaa=(return)true=(return)false 2.3 恰好三个 思路 不用管到底是哪个字符,我们只需要验证是不是三个字符即可,所以先把所有字符变成一样的,例如c 接下来我们要判断的不是ccc=(return)true,因为字符串cccc同样包含ccc, 我们首先就排除掉大于3个字符的,其一定包含四个及以上的字符串 这时候对只有三个字符的返回true 剩下的也是false 代码 12345a=cb=ccccc=(return)false ccc=(return)true =(return)false 2.4 余数 思路 这个是return使用的一个示例,所以我们考虑的仍然是只关心字符串长度,不关心内容 将所有都替换成同样的字符 发现求的事余3,我们只需要每次都将三个字符的串放空,剩下的字符串长度就是总长度余3的结果 将长度换成数字 代码 这个思路在后续也有用 123456a=cb=c ccc= cc=(return)2c=(return)1=(return)0 2.5 奇数 思路 划分问题 终于开始上难度了,但是这个 思想其实不难理解,我们先做一个简单的想法,我如何判断一长串a是否由奇数组成? 考虑到字符串长度为1&lt;=n&lt;=7,很容易知道0,1,3,5,7为可能的长度 暴力枚举虽好,但是长度有点太大了,我们可以用另一个方法:奇数减去2之后仍然为奇数 所以我们很容易想到aaa=a来清理串,为什么不能是aa=? 因为这样没有办法确认是刚开始就没有a,还是被偶数a消除掉的 此时长度0,1,2,只有2表示原串是偶数 做法 然后我们知道要去做什么了:把三个字符串相同的集中在一起,相当于按顺序再为这三个字符轮流做上述检查操作 所以需要排序,让相同字符待在一起 接下来问题就好解决了 代码 12345678910ba=abcb=bcca=acaaa=abbb=bccc=caa=(return)falsebb=(return)falsecc=(return)false=(return)true 进阶 你肯定要回来看的,如果你看不懂2.6的话 发现了什么?我们将同样的情况循环了3遍,也就是说,在单独讨论的时候a,b,c其实是等价的,有没有什么办法将它们的等价用代码解释出来? 一个很有趣的想法是将b,c转换成等价a,最后判断三段a是否都满足奇数 一点点魔法:设置一个障碍,让所有相邻相同的字母没有障碍,而让不同的字母之间有障碍 考虑如下代码的运作 12345ba=abcb=bcca=acb=xxaxc=xaxx 这种情况下会发生什么:相邻的b变成了中间隔着3个x的a,不同字母之间隔着2个x 更加显式地能看到假设 bacacc: 123aabccc-&gt; aaxxaxxxaxxxaxxxaxx-&gt; a|a| xxax |xaxx|xaxx|xaxx 仔细观察,发现相隔3个x的都能去掉!,此时会变成用两个x阻隔的三个段,每个段里面的a的个数是a或b或c的个数,此时bacacc变成aaxxaxxaaaxx 然后判断即可 得出来新的代码如下 123456789ba=abcb=bcca=acb=xxaxc=xaxxxxx=aaa=a #等价处理aa=(return)false=(return)true 这种等价思想很重要,在之后会多次使用 其实这种等价想法在于什么:在于让相同字母之间的间隔一样,不同字母的间隔不一样,以这种思路你完全可以设计如下方法: 12345678910111213141516#其中()表示重复几次b=x(n)ax(m)#则c和b之间的距离也应为n,b和b之间距离为m+n#所以c=x(n-m)ax(2m)#符合以上要求的都可以替换#比如以下代码n=6,m=3,一样可以通过ba=abcb=bcca=acb=xxxxxxaxxxc=xxxaxxxxxxxxxxxxxxx=aaa=aaa=(return)false=(return)true 2.6 独一无二 思路 这里建议先看一下上面的拓展 然后我们先翻译一下题目:希望这个长字符串出现的单字符字符串有且只有一个: aaabccc:只有一个a,是我们需要的 aaabacc:b和a都有,是错误的 实际上我们要做的是在aaa=aa;bbb=bb;ccc=cc之后,看单个的不成对字母有几个 我们只需要知道是不是等于1 和上题拓展法类似,我们等价之后再做类似操作,现在得出来的因为没有排序,我们现在能保证的是 相同字母之间x个数为0或者3 不同字母之间x个数为1或者2 由上述两条我们将串收敛一下,把相等相邻的聚在一块,然后格式一下彼此之间距离 此时出现的就是axaaaxaaxa之类的东西,更进一步地,我们将所有长串都收成空串 此时我们要找的是此时里面是不是只有一个a 看到a就return肯定不行,但是我们能先把多个a存在的删掉,其格式一定为axaxa之类,因为我们上述操作不相同的单字符串串之间一定有一个x阻隔 这时候就有只剩下a的情况了,此时是我们想要的 剩下的情况就是全是长串,也是我们不想要的 代码 123456789b=xxaxc=xaxxxxx= #这之后相邻的同字符的串就是相邻的axx=x #此时不同串之间相差1xaaa=aa aa= #两步除长串axa=(return)falsea=(return)true=(return)false 2.7上升 思路 排序 做之后还会有效的两两对比 先确定是不是c比d多,再确定是不是b比a多 建议先看下面的两个 实现上面的体现 c比b多则b全部化为d,此时还有c剩余 d比a多则a全消失,d还有剩余 也就是说dc存在的时候其实是(bcc)还有剩,合法性足够强 我或许需要一些更加显然的理解,但是现在没有...以后可能试试 12345678ca=accb=bcba=ab #先排序bc=d #合法情况是adcbd=db #此时d代表的是bcad= #消去abc 此时如果合法一定是dcdc=(return)true=(return)false #其他就都不合法 2.8最多 思路 对于这种考虑总体字母的,我们先把他们放在一起,先排序 我们考虑到排序,所以我们只要比较三者的多少,很明显能考虑到两两对比 接下来我们最好看代码讲解 代码 12345678910111213ca=accb=bcba=ab #先排序bc=d bd=db #此时d代表的是bcad= #消去abc,接下来剩下的就只有一个或两个字母,一定,而且不是bc,把三种组合罗列一下就是结果,只有一个字母显然是答案ac=ab=a=(return)ab=(return)bc=(return)c 2.9最少 思路 思路与上面的类似 直接看代码吧 123456789101112ca=accb=bcba=ab #先排序ab=ddb=bddc= #销去了abc,可能剩下ad,ac,bc d=(return)c #d存在说明d比c多,也就是ab组合都比c多ac=(return)b bc=(return)a","categories":[],"tags":[{"name":"A=B","slug":"A-B","permalink":"https://noirzh.github.io/tags/A-B/"}]},{"title":"A=B 第一章题解","slug":"第一章","date":"2023-11-01T13:04:50.000Z","updated":"2023-11-11T08:49:05.676Z","comments":true,"path":"2023/11/01/第一章/","permalink":"https://noirzh.github.io/2023/11/01/%E7%AC%AC%E4%B8%80%E7%AB%A0/","excerpt":"","text":"前言 A=B语言也较为特殊,可以认为整体是个循环体,但是是每次循环只要能够执行一条命令就去执行,然后就重新回到循环开头 这个性质会在后续不断应用 而且其本质在做的就是字符串替换 1.1 A到B 1a=b 1.2 大写 123a=Ab=Bc=C 1.3 去重 思路 显然我们最后要保留的状态是没有连续字母 只需要将重复的几个压成一个就行,不过要注意A=B这个语言的特殊性 代码 123aa=abb=bcc=c 1.4 去重 2 思路 同理,这个是把连续的a压没, 这里之所以会有aaa,而不是直接aa=是因为假如只压缩的可能会剩下来:例如aaa会被替换成a ,我们这么做的本质是将多的字母先压成两个,再把这两个消除掉 12aaa=aaaa= 1.5 排序 思路 研究语言的必经之路,排序,注意到我们现在在做的是替换字符串 我们的目的是希望各个字母都在其应该在的位置,但我们不知道数组下标,怎么样能达成这两个条件呢? 我们需要一个只看相邻的排序算法,也就是冒泡算法,实现起来不难,如下 代码 看到了吗,本质就是大的向后挪动,这个在单步运行时候看的更清楚 123ba=abcb=bcca=ac 这个排序在之后会常用到的,当我们只关心字母数量之类的而不关心其位置的时候 1.6 比较 思路 比较a和b的多少,还记得去重怎么做的吗?把两个相同的数摁在一起消除 这个题也一样,我们把两个不同的字母摁在一起消除,剩下的就是多的字母 值得一提的是压字母存在两个情况 代码 1234ab=ba=aa=abb=b","categories":[],"tags":[{"name":"A=B","slug":"A-B","permalink":"https://noirzh.github.io/tags/A-B/"}]},{"title":"翻译:Efficient parallel branch-and-bound approaches for exact graph edit distance problem","slug":"translate_Efficient parallel branch-and-bound approaches for exact graph edit distance problem - 副本","date":"2023-11-01T13:04:50.000Z","updated":"2023-11-12T06:19:53.579Z","comments":true,"path":"2023/11/01/translate_Efficient parallel branch-and-bound approaches for exact graph edit distance problem - 副本/","permalink":"https://noirzh.github.io/2023/11/01/translate_Efficient%20parallel%20branch-and-bound%20approaches%20for%20exact%20graph%20edit%20distance%20problem%20-%20%E5%89%AF%E6%9C%AC/","excerpt":"","text":"来自链接 摘要 图编辑算法(Graph Edit Distance ,GED)是一种在图匹配领域广泛使用的方法.它通过计算将一个图转化成另一个图的最小编辑成本来衡量两个图的相似性或差异性.这个过程看起来很简单,但是是NP难问题并且非常耗时,因为它的搜索空间是指数级增加的.一个解决这个问题的最优算法是分支限界法(Branch and Bound，B&amp;B),通过对搜索空间进行隐式枚举而不是而不是基于剪枝技术的全部枚举,来减少探索整个搜索空间的实践.然而当处理大型问题实例的时候,B&amp;B算法探索整个搜索空间所需要的时间仍然太长了,它在此时依然是不够有效的.为了解决这个问题,在本文中我们提出了三种基于共享内存的B&amp;B并行方法来利用多核CPU处理器.第一种是一种工作窃取的方法,多个B&amp;B实例并发搜索单个搜索树,比顺序版本最多快24倍.其次是一种基于树的方法,由独立的B&amp;B实例同时搜索搜索树的多个部分,能够提速28倍,最后,由于GED问题的不规则特性,提出了两种负载均衡策略来保证并行进程之间的负载均衡,达到了令人惊叹的300倍,所有的实验都在知名的数据集上进行过了. 1. 介绍 图编辑算法(Graph Edit Distance ,GED)是一种在图匹配领域广泛使用的方法来计算两个图之间的最小距离.GED算法的目的是计算两个图之间的不相似的总和.换句话说,它代表将一个图编辑成另一个图所需要的最优操作集的成本1.允许的操作包括插入,删除和增加,这三种操作可以运用在顶点或者边上.这个问题由于其NP难特性而被认为是非常具有挑战性的2,这意味着计算两个图之间最小距离的时间复杂度随着顶点数量的增加呈指数级增长.GED的重要性来自于它的多种使用用例.它可以用于精确匹配也可以用于能容忍一定错误的非精确匹配.并且,GED可以用于多种领域3,特别是在与模式识别相关的领域,比如手写识别456,个人识别和认证(例如指纹识别)7,文档分析8910,和图数据库搜索11.它也可以被用于机器学习,最近邻居分类和数据挖掘领域.12 为了计算两个图之间的最佳编辑距离,蚊香13经常使用的基于A*14的搜索算法.然而,这种方法需要大量内存资源,这使得其不能被用于处理大型的图.分支限界法(B&amp;B)是一种广为人知的技术,它通过智能枚举搜索空间来解决最优化问题.这个方法用两个组件,分支(branching)和界限(bounding),将搜索空间建模成一棵树.分支是一个递归的过程,它将一个给定问题的搜索空间划分成多个更小的子问题,并对这些子问题用同样的方式处理,知道找到解决方法.在分支过程结束后,界限操作符评估每一个生成的子问题是否可能包含好的解决方案.B&amp;B算法使用多种技术(消除和选择)来避免探索没有最优解可能的子问题(分支)并家扩搜索过程.由于GED问题的复杂性,它对于一般图来说是NP难问题15,B&amp;B算法需要很长的实践去找到最优解,特别是在解决大型图问题的时候.为了客服这个缺点,我们认为并行计算是一个减少这类问题的运行时间的有趣的方法. 在这片论文之中,我们研究了利用单台计算机的计算资源所带来的影响和可能的收益.事实上,现在的的大部分计算机从硬件上来看都是并行的,能够提供可观的计算能力,尽管在大部分情况下都没能被利用.因此.也为了评估使用并行方法可能得到的收益,我们提出了几种B&amp;B算法.这里的目的是评估每一个并行方法在减少执行时间和有效探索整个搜索空间的影响和行为.我们给出的方法可以归类成高级并行化,其中多个B&amp;B算法的实例同时探索搜索空间. 本文提出了两个并行算法,第一种是基于工作窃取策略,用以在不额外增加内存使用的条件下加快对搜索树的顺序搜索.因此,我们用多个B&amp;B实例同时探索同一颗存储在共享内存空间中的搜索树,所有并行的B&amp;B实例都可以对这个搜索树进行读/写操作.在参考数据集上使用16核CPU的实验显示,相对于顺序版本,速度提升24倍.为了更有效地探索这个搜索空间,也为了研究多样化的影响,我们提出了第二个B&amp;B算法.后者用基于树的方法表示,用多个独立的B&amp;B实例并行地探索整个搜索树的多个部分.因此,更新上界(UB),这最终能够改善一定复杂度.这个算法基于主从策略(Master-Worker),主节点将搜索树分成多个B&amp;B实例,也就是工作者(Workers),在这之后,每一个工作者在自己的内存空间之中构建自己独有的搜索树,进程间唯一共享的信息就是更新的上界的值,这在每一次一个更优路径被发现的时候更新.这个算法得到的结果显示多样化探索过程对性能产生了积极的影响,相比于顺序B&amp;B实例,提速了约28倍.然而,因为搜索树中的子问题的负载不均衡,许多工作者很快地结束了工作(空闲),然而其他会需要运行很长的时间.解决GED问题的负载平衡策略的影响在Abu-Aisheh等人的研究16，17中没有得到很好的研究.因此,我们提出了两种原创的负载均衡策略来避免工作者的共线.我们的第一种负载均衡策略包括将主节点当做负载均衡器,听过改变它的搜索策略来保证子问题的大量可用性.这个避免空闲的想法就是给所有的并行工作者读写权限来让它们在自己的工作池为空的时候从负载均衡器的工作池之中选取一个子问题.第二种保证工作者之间的负载平衡的方法是将前两个并行算法结合起来.这里的想法是允许工作者在本地进行次迭代,接着将它们自己本地工作池整合进一个共享的全局工作池.用参看数据集刨出来的结果显示了将多样性和负载均衡结合起来带来的好的影响,并且,增加负载均衡算法能够将基于树的并行算法提升高达11倍. 本文余下的内容总结如下.在第二节提出了一些基础的有关GED的符号和定义,在第三节中,我们讨论相关的工作.在第四节描述了串行B&amp;B算法和它的组成,在第五节我们详细介绍我们提出的并行B&amp;B算法和负载均衡策略.在第六节报告计算结果,最终,在第七节提出了结论和展望. 2.问题定义 在接下来的部分,我们首先定义了一些基本的概念接下来去正式地定义GED问题 2.1图(Graph) 一个图是一个用于建模对象之间的成对关系的结构.18,它包含了一组由一组边连接起来顶点, 正式定义中,一个带标签的图可被表示为,在其中 ,表示包含n个顶点的集合 .表示包含个边的集合 是顶点的标记函数，也就是将每个顶点映射到一个标记的函数，表示为: 是边的标记函数，也就是将每个边映射到一个标记的函数，表示为:. 和被限制为可以由一组整数描述的标签,向量空间或者符号标签 在这篇论文之中,我们考虑简单的无向无环标记图. 2.2 GED操作 在GED问题之中,一个将图转换成图的编辑路径由一组图的编辑操作组成.每一个编辑操作对顶点,边或者顶点和边执行一次操作.在本文之中,我们采用一种以顶点为中心的方法,其变形都是在顶点上进行的,而其中隐含了对边的操作.因此,只有一下三种基本备案及操作是被允许的:插入(),删除()和替换() 我们描述一个顶点来自于图,以及领一个顶点来自于图,我们表示为 将顶点替换为 ,顶点从之中删除 顶点加入到之中 2.2.1隐含的边操作 在以顶点为中心的算法之中,对于边的编辑操作是隐含的,事实上,一个边的替换,删除或者增加取决于它的相关顶点的编辑操作19.让我们考虑图之中的两个顶点,和另外两个顶点在图之中.如果我们在顶点和进行如下的两个编辑操作和.可以分别区分出三种边的隐含操作: 如果在中和之间存在一个边,也存在一个边连接和,那么就被替换掉,表示为 如果在中和之间存在一个边,而之中没有连接和的边,那么就在之中删除,表示为 如果如果在中和之间不存在边而存在一个边,那么就被加入到了之中,表示为 注意当一个顶点从之中删除的时候,与它相连的所有边都被自动删除,类似地,吐过一个顶点被插入进所有在之中预期相连的边会被插入,如果这个边的另一个端点已经存在于之中 2.3成本函数 在GED之中,成本函数是一个重要的组成部分.成本函数为每一个对于边或者顶点的操作分配一个值(成本).因此,图编辑的成本分配影响着最优编辑路径.成本函数提供了一个将与对象相似性有关的领域信息融入进来的有效方法.对于一个特定操作的成本实在底层标签字母表的层面定义的,三种编辑操作的成本给出如下 我们应该注意如果这两个顶点或者边的拥有相同便签的时候,其替换成本为0. 2.4图编辑距离 让和为源图和目标图,分别地,和之间的图编辑距离由表示,代表着两个图之间的差异程度.换句话说,它代表着一组将转换成的最优编辑集合(在成本角度上) 最终,和之间的图编辑距离(GED)定义为 其中表示为所有的将转化成的编辑路径的集合.每一个路径都包含着一组编辑操作,并且表示编辑操作的成本20 2.5举例 我们将源和目的图表示在在图1之中,我们让删除和插入的操作成本为2,替换的成本为1,那么将图编辑成图的最优路径可以由操作四个顶点的替换得到,这意味着要替换三条边,并且删除其他的两条,完整编辑路径如下 因此将转化成的最优路径的成本 图1:源图和目的图 3.相关工作 在模式识别之中,一个真实世界的对象通常由数组向量(图)来表示.这种表示对评议,缩放和旋转等操作是敏感的,因此我们用以图为基础的表示方法来克服这些问题.以图为基础的表示方法具有不可更改性以及更强的表现能力,因为我们可以在断电或者边上增加信息.精确匹配(Exact-GED)假设环境是无噪音的,因此它认为当且仅当两个图(和)之间的图编辑距离(GED(,))为0的时候,二者是匹配的.然而,由于噪音因素,相同对象的两个图可能并不完全匹配.在这种情况下,我们称之为非精确匹配(Inexact-GED),当两个图之间的编辑路径在给定阈值的以下的时候就认为是可以接受的陪陪.因此,GED可以在精确匹配和非精确匹配的场景之中运用.一些应用需要将一个图转化成另一个的最优方法(编辑路径).因此它们通常使用最优化算法,像是A*和B&amp;B算法.额俺儿,B&amp;B算法也可以被用于得到一个次优解,例如在计算规定时间之后就停止.在本节的剩余部分,我们会着重于现有的最优GED问题的处理工作,这些工作基于树遍历和并行计算.21 在1983年A. Sanfeliu 和 K.-S. Fu 提出了GED22,而在其出版的同一年,Bunke 和 Allermann23 首次实现并调整A*算法来解决GED问题.他们的想法是将第一个图的所有元素映射到第二个图之中来寻找最优解.因此,生成了一个为所有可能解建模的搜索树.映射使用三种编辑操作:删除,增加和替换.他们用一些小规模的图证明了这一算法. A*GED算法能够找到最优解,但是存在巨大的计算和空间复杂度.在这一篇论文中24,作者提出了GED问题的近似算法,称之为A*-波束搜索(A*-Beamsearch).这个算法用一个特定的大小s来限制A*的优先队列的大小,只保留有s个具有醉的成本(实际成本+估计成本)的编辑路径,波束搜索的队列越大,这个算法越准确. 为了加速A*算法的搜索过程,Riesen 等人25 提出了一个二分启发算法 (bipartite heuristic),来给出对于成本下界(h)的评估.这个启发式基于二部图匹配.首先,创建两个成本矩阵,分别对应图一和图二之间的三种操作所对应的顶点和边的不同分配情况.之后,用Munkres算法2627来分别计算出边和点的最佳分配.最后,近似值h就是边的最优分配和顶点的最优分配之和,在28这篇论文之中,作者用他们的启发式算法近似地解决了GED问题.因此,为这个问题提出了一个很好的上界.二分启发式算法在2930中被进一步讨论和优化来更准确地计算下界 在31这篇论文中,Abu-Aisheh等人使用深度优先算法(DFS)来最优地解决GED问题.这位作者的目标是相比对于A*算法来减少大量使用的内存空间.这个算法在开始的时候使用Munkres算法来对顶点进行排序,然后用DFS策略来探索搜索空间.在32这篇论文中,作者提出了一种DF-GED的共享内存并行方法,称之为PDFS.在PDFS之中,多个并行的DF-GED实例同时探索搜索空间.并且,这位作者使用了负载均衡策略避免并行线程的空闲.最后结果显示,相比于DF-GED,这个算法提升了20%.但是这个实验并没有用经典指标(加速比和效率)来表示并行化和负载均衡策略的影响.在33之中,作者提出了一个DF-GED算法分布式内存版本.他们给出的并行方法使用主从模式,并且使用Hadoop framework34实现.这个分布式版本在运行时间上与串行版本相近. 在35之中, Gouda 和 Hassaan提出了一个称之 CSI_GED 的基于边的深度优先算法来解决统一的GED问题,统一的GED问题指的是所有的编辑操作的成本都是相同的.这位作者的主要想法就是将第一张图的所有边都用射到第二张图的边上,顶点隐含在其中,详细的实验部分验证了所提出的方法. 在36[^25]之中Blumenthal和Gamper修改了在37中的DF-GED算法,以解决具有统一编辑成本的GED问题.在这种情况下,使用Munkres算法估算成本的时间复杂度可以从立方降低到线性时间.在同一篇论文之中,作者提出了在38中的CSI_GED算法的一般化,称其为CSI_GEDnu来覆盖非统一编辑成本问题.这个一般化算法使用Munkres算法39来计算未来预估成本.在[^26]之中,相同的作者提出了一个用来近似或者准确地解决GED问题的C++的库,称之为GEDLIB.这个库包含了多种用于GED的文献算法,也可以是其他新算法的基础实现. 在[^27]之中,Chang等人提出了了GED问题的新的下界,这极大减少了DFS算法和A*算法的内存占用.在这个下界的基础上,他们开发了能够处理多达六十个顶点的图的AStar+-LSa 和 AStar+-BMa算法. 在[^28]中,Wang等人针对精确GED问题提出了在[^27]中提出的AStar+-LSa算法的并行实现.他们的并行算法被称之为PGED,其主要思想是将A*算法最耗时的步骤(搜索和最优顶点映射)分配给多个线程同时执行.他们的实验结果显示,与算法的串行版本相比,快了两倍. 在精准匹配领域,Allen等人在1997年发表了一个并行算法[^29].他们的算法适用于两个拥有相同顶点数量的图,其中距离的计算称之为关系距离,通过寻找让和对其的最优顶点排列就能找到和之间的最优匹配.对于每一种可能的排列,会对和之间的边进行比较,对于每一条不匹配的边,会增加一个错误.并行部分基于启发式B&amp;B搜索算法来计算出和之间的估计距离(下界).一个很重要的观点认为,该算法被设计为适用于单指令流/多数据流(SIMD)并行性的特定体系结构,这个实验在10个顶点到27个顶点的中小型图上进行,用拥有1024个处理器的大规模并行计算. 因为GED问题的NP难特性,计算出来小型图的最短距离就要花费很长时间.因此.大部分上述的文献只用小型的数据集或者在特定时间内探索部分搜索树来在概念上证明其算法.在[^30]之中,我们提出了一个基于树的近似方法来算出一个接近最优解的结果.因为探索整个搜索树是不切实际的,这个算法在每棵树层中只保留最优节点用以后续探索,这极大减少了计算时间也并没有损耗太多解决方案的质量. 为了解决更大的图,也为了报告并行在最优解决精准GED问题上的影响,我们提出了几种并行的B&amp;B算法和负载均衡策略来加快搜索过程以及尽可能地有效利用现代计算机的可用计算资源. download 4.GED的B&amp;B算法 分支限界法(B&amp;B)是广泛用于最优解决组合优化问题的基数.它在1960年被A. H. Land 和 A. G. Doig提出用以解决离散规划问题[^31].这些算法对整个搜索空间进行智能而准确地枚举,将其建模成一个搜索树,并对这颗搜索树用分支限界操作来探索.分支限界法的目的是去找到将一个图转换成另一个图从成本角度来说最优的编辑路径.搜索树的节点的分支操作会将它的搜索空间分解成几个更小的子问题而产生一组后继节点.这些后继节点会同样进行分支操作直到找到解决方法.在分支之后,限界操作评估每一个后继节点的改善已经找到的找到最优解的能力.如果不能改善,对该分支修剪并删除后续结点,此外,算法1描述了使用B&amp;B算法的一般结构. 在接下来的内同理,我们介绍对B&amp;B算法的几种操作进行修改让其适用于GED问题. 4.1 分支 B&amp;B算法在由整个搜索空间建模成的搜索树上进行分支操作,B&amp;B的搜索树用分支操作生成.它将问题(树的节点)分解成若干较小子问题,并对这些子问题重复上述操作直到达到叶子结点.对GED问题的分支是基于将图g1的节点映射到图g2的节点上的思想,也就是说,我们用以顶点为中心的算法,映射操作执行几种传统的图编辑操作:增加,删除和替换.形式上,一个搜索树的节点的特征包括 一组已知的过去编辑操作,称为路径(path),表示为其中是编辑操作之一(增加,删除和修改) 两个图(和)中剩余的节点,分别表示为和 两个图(和)中已经加工的节点,分别表示为和 在上述情况下,根节点(最初的问题)可以被定义为 对于一个搜索树节点的分支操作都会通过将一个顶点替换成在之中的任意一个结点来产生个后继节点.换句话说,每个后继节点表示一个节点通过节点进行映射,定义如下 (需要注意的是这里的) 除了上述的后续子节点的生成方法之外,我们增加了一个表示顶点被删除后产生后续结点.定义如下 这个过程会一直重复直到到达叶子节点,也就是在这种情况下,如果和第二张图有关的剩余的节点不为空()我们一次性地将中剩下的所有节点插入,表示如下 图2展示了一个用以解决GED问题的搜索树的例子,在这个图的每一个层次,来自第一个图的一个顶点被中的剩余节点以及生成删除操作的映射. 图2,与GED问题相关的一般搜索树方案 5.提出的GED问题的B&amp;B并行算法 6.表现分析 7.结论和展望 引用 Inexact graph matching for structural pattern recognition 链接↩︎ Comparing stars: On approximating graph edit distance 链接↩︎ Structural Pattern Recognition with Graph Edit Distance: Approximation Algorithms and Applications, Advances in Computer Vision and Pattern Recognition, Springer International Publishing (2016) 链接↩︎ K. Riesen, S. Fankhauser, H. Bunke, Speeding Up Graph Edit Distance Computation with a Bipartite Heuristic, in: MLG, 2007. Google Scholar↩︎ Approximate graph edit distance computation by means of bipartite graph matching 链接↩︎ Z. Abu-Aisheh, R. Raveaux, J.-Y. Ramel, P. Martineau, An exact graph edit distance algorithm for solving pattern recognition problems, in: 4th International Conference on Pattern Recognition Applications and Methods 2015, 2015. Google Scholar↩︎ Approximate graph edit distance guided by bipartite matching of bags of walks 链接↩︎ Approximate graph edit distance computation by means of bipartite graph matching 链接↩︎ A graph distance measure for image analysis 链接↩︎ Recent advances in graph-based pattern recognition with applications in document analysis 链接↩︎ Graph similarity search with edit distance constraint in large graph databases 链接↩︎ Approximate graph edit distance computation by means of bipartite graph matching 链接↩︎ Structural Pattern Recognition with Graph Edit Distance: Approximation Algorithms and Applications, Advances in Computer Vision and Pattern Recognition, Springer International Publishing (2016) 链接↩︎ A formal basis for the heuristic determination of minimum cost paths 链接↩︎ Comparing stars: On approximating graph edit distance 链接↩︎ Z. Abu-Aisheh, R. Raveaux, J.-Y. Ramel, P. Martineau, A Distributed Algorithm for Graph Edit Distance, in: DBKDA 2016, 2016, p. 76. Google Scholar↩︎ A parallel graph edit distance algorithm 链接↩︎ Introduction to Graph Theory, vol. 2 Google Scholar↩︎ Approximate graph edit distance computation by means of bipartite graph matching 链接↩︎ Approximate graph edit distance computation by means of bipartite graph matching 链接↩︎ Thirty years of graph matching in pattern recognition 链接↩︎ A distance measure between attributed relational graphs for pattern recognition 链接↩︎ Inexact graph matching for structural pattern recognition 链接↩︎ Fast suboptimal algorithms for the computation of graph edit distance 链接↩︎ K. Riesen, S. Fankhauser, H. Bunke, Speeding Up Graph Edit Distance Computation with a Bipartite Heuristic, in: MLG, 2007. Google Scholar↩︎ Algorithms for the assignment and transportation problems 链接↩︎ Assignment Problems: Revised Reprint 链接↩︎ Approximate graph edit distance computation by means of bipartite graph matching 链接↩︎ Computing upper and lower bounds of graph edit distance in cubic time 链接↩︎ Correcting and speeding-up bounds for non-uniform graph edit distance 链接↩︎ Z. Abu-Aisheh, R. Raveaux, J.-Y. Ramel, P. Martineau, An exact graph edit distance algorithm for solving pattern recognition problems, in: 4th International Conference on Pattern Recognition Applications and Methods 2015, 2015. Google Scholar↩︎ A parallel graph edit distance algorithm 链接↩︎ Z. Abu-Aisheh, R. Raveaux, J.-Y. Ramel, P. Martineau, A Distributed Algorithm for Graph Edit Distance, in: DBKDA 2016, 2016, p. 76. Google Scholar↩︎ Hadoop-The Definitive Guide: Storage and Analysis at Internet Scale (revised and updated) Google Scholar↩︎ Csi_Ged: An efficient approach for graph edit similarity computation 链接↩︎ Z. Abu-Aisheh, R. Raveaux, J.-Y. Ramel, P. Martineau, An exact graph edit distance algorithm for solving pattern recognition problems, in: 4th International Conference on Pattern Recognition Applications and Methods 2015, 2015. Google Scholar↩︎ Csi_Ged: An efficient approach for graph edit similarity computation 链接↩︎ Algorithms for the assignment and transportation problems 链接↩︎","categories":[],"tags":[{"name":"论文","slug":"论文","permalink":"https://noirzh.github.io/tags/%E8%AE%BA%E6%96%87/"},{"name":"翻译","slug":"翻译","permalink":"https://noirzh.github.io/tags/%E7%BF%BB%E8%AF%91/"}]},{"title":"题解-最长不相等子序列 II-DP,时间On2,空间On","slug":"题解-最长相邻不相等子序列","date":"2023-10-15T07:24:12.000Z","updated":"2023-11-12T07:05:20.137Z","comments":true,"path":"2023/10/15/题解-最长相邻不相等子序列/","permalink":"https://noirzh.github.io/2023/10/15/%E9%A2%98%E8%A7%A3-%E6%9C%80%E9%95%BF%E7%9B%B8%E9%82%BB%E4%B8%8D%E7%9B%B8%E7%AD%89%E5%AD%90%E5%BA%8F%E5%88%97/","excerpt":"","text":"Problem: 100077. 最长相邻不相等子序列 II [TOC] 思路 注意到数据范围很小,1000,可用的复杂度较高 对于常见的求最长合法子序列可以用DP尝试(一般这种解法是)的 解题方法 设计状态转移方程,设表示以i为结尾的最长子序列的长度,由题意可知 和同时满足三个条件 能得出答案的长度,为了得到字符串数组需要更多信息 这里用pre数组记录每一个以为结尾的最长子序列的倒数第二个元素,如果不存在就为 &gt; 时间复杂度, &gt; 空间复杂度, Code 将最后查找答案的那一步放在dp计算之中也可以保证计算正确 []123456789101112131415161718192021222324252627282930313233class Solution: def getWordsInLongestSubsequence(self, n: int, words: List[str], groups: List[int]) -&gt; List[str]: def isLegaldistance(a:str,b:str): #这里将两个条件混合起来,更方便一些 if len(a)!=len(b): return False res=0 for x,y in zip(a,b): if x!=y: res+=1 if res&gt;1: return False return True #dp[i]表示以i为结尾的子序列的最大长度 #pre[i]表示以i为结尾的子序列的倒数第二个元素在words中的序列 resIndex=0 dp=[1]*n pre=[-1]*n for i in range(n): s1=words[i] for j in range(i): if groups[i]!=groups[j] and dp[j]+1&gt;dp[i] and isLegaldistance(s1,words[j]): dp[i]=dp[j]+1 if (dp[i]&gt;dp[resIndex]): resIndex=i #只有更新时才有可能出现最大值 pre[i]=j res=[] while resIndex!=-1: res.append(words[resIndex]) resIndex=pre[resIndex] return res[::-1]#从后向前做的遍历,所以要返回反转后数组","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://noirzh.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"Python","slug":"Python","permalink":"https://noirzh.github.io/tags/Python/"},{"name":"动态规划","slug":"动态规划","permalink":"https://noirzh.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"题解-移动机器人-数组计算的三种思考方式方式(动态规划,贡献,前缀和)与相关证明","slug":"题解-移动机器人","date":"2023-10-10T00:04:17.000Z","updated":"2023-11-12T07:01:26.925Z","comments":true,"path":"2023/10/10/题解-移动机器人/","permalink":"https://noirzh.github.io/2023/10/10/%E9%A2%98%E8%A7%A3-%E7%A7%BB%E5%8A%A8%E6%9C%BA%E5%99%A8%E4%BA%BA/","excerpt":"","text":"Problem: 2731. 移动机器人 [TOC] # 前述条件 1. 碰撞和1503. 所有蚂蚁掉下来前的最后一刻类似,注意到对于身份没有要求,所以可以直接认为两个机器人碰撞是交换了二者的身份,也可以认为是穿过去了 2. 因此能够得到机器人的最终位置,为了方便计算,我们排序 3. 数据量为,暴力求解不现实 4. 以下是三种常用的解决方法,这三种思路最开始的进入方式不同,但是都能得出正确结果 # 两种对于距离的计算方法 算法的时间复杂度均为 ## 动态规划 ### 思考方式与证明 1. 假设已经计算出来了之前所有的机器人两两之间距离之和为 2. 增加一个元素,观察其和之前的所有机器人之间的距离之和,能够发现 1. 实际上就是与之前的每个元素计算距离 2. 与之间的距离实际上分别是是与之间的距离加上与之间的距离,共个 3. 上述结论可以推导: 设表示和之间的距离之和,有 ### 代码 可以看出来这个公式只与前一个状态有关,因此可以优化空间 []123456789101112131415class Solution: def sumDistance(self, nums: List[int], s: str, d: int) -&gt; int: mod=1000000007 n=len(nums) for i,a in enumerate(s): nums[i]+=d if s[i]=='R' else -d nums.sort() res=0 distance=0 for i in range(1,n): distance+=i*(nums[i]-nums[i-1]) #这个方法对于只int的话4*(10**9)会超范围 distance%=mod res+=distance return res%mod ## 贡献距离法 ### 思考方式 1. 对于这种什么什么之和的问题可以考虑计算每个片段对结果的贡献 2. 在这个题目之中片段就是每个元素之间的距离,我们需要计算的就是这段距离在结果中出现了多少次 3. 为了方便理解将每次计算距离视为两点之间的连线,看片段上线的数目就知道这个片段的使用次数 4. 从这一的角度来看:从连出去了条线,每条线都经过了,所以得出段的贡献是 5. 从的角度来看,连出去的也就是条线覆盖了 1. 但还不够,注意到发出去的线只有一条落在了上,剩下的线也覆盖了 6. 希望确切地知道此时到底有多少条线覆盖了这段距离 ### 证明 1. 设表示到这段距离对结果的贡献次数 2. 同时可知也表示此时距离上面的线段数量 3. 从a[i]发出的所有向右的线都会做贡献,这个次数为 4. 发现之前的线段,也就是参与了计算的线段,有一部分落在了上,剩下的部分继续参与的计算 5. 可知落在上的线段实际上是a[i]发出的指向左边的线段,其数量为 6. 综上 7. ### Code 可以看出只与前一个状态有关,进行空间优化 代码为了方便对于计算的是到 []1234567891011121314class Solution: def sumDistance(self, nums: List[int], s: str, d: int) -&gt; int: mod=1000000007 n=len(nums) for i,a in enumerate(s): nums[i]+=d if s[i]=='R' else -d nums.sort() pre=0 res=0 for i in range(n-1): pre=(pre+n-2*i-1)%mod res=(res+(nums[i+1]-nums[i])*pre)%mod return res # 前缀和的形式化证明 下面是灵神的证明方式,与上面的证明相比更加数学,如下 $ (a[i]−a[0])+(a[i]−a[1])+⋯+(a[i]−a[i−1])=i⋅a[i]−(a[0]+a[1]+⋯+a[i−1])$ 可根据前缀和求 下面是灵神的代码 ## 代码 12345678910class Solution: def sumDistance(self, nums: List[int], s: str, d: int) -&gt; int: for i, c in enumerate(s): nums[i] += d if c == 'R' else -d nums.sort() ans = s = 0 for i, x in enumerate(nums): ans += i * x - s s += x return ans % (10 ** 9 + 7)","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://noirzh.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"Python","slug":"Python","permalink":"https://noirzh.github.io/tags/Python/"},{"name":"动态规划","slug":"动态规划","permalink":"https://noirzh.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"脑筋急转弯","slug":"脑筋急转弯","permalink":"https://noirzh.github.io/tags/%E8%84%91%E7%AD%8B%E6%80%A5%E8%BD%AC%E5%BC%AF/"},{"name":"排序","slug":"排序","permalink":"https://noirzh.github.io/tags/%E6%8E%92%E5%BA%8F/"},{"name":"前缀和","slug":"前缀和","permalink":"https://noirzh.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"}]},{"title":"题解-英雄的力量","slug":"题解-英雄的力量","date":"2023-07-31T21:51:11.000Z","updated":"2023-11-12T06:20:41.030Z","comments":true,"path":"2023/08/01/题解-英雄的力量/","permalink":"https://noirzh.github.io/2023/08/01/%E9%A2%98%E8%A7%A3-%E8%8B%B1%E9%9B%84%E7%9A%84%E5%8A%9B%E9%87%8F/","excerpt":"","text":"Problem: 2681. 英雄的力量 [TOC] 思路 选取与顺序无关先排序 接下来只要枚举所有子序列的最大值的平方和最小值的乘积之和 注意到只和最大值和最小值有关 解题方法 确定了子序列的最大值之后,我们只需要确定子序列里面各个值最小值出现了几次 也就是确定排序后的必选且为最大值时,我们假设此时在答案中与除自身之外他的平方相乘的所有值之和为,此时有答案 不去管现在为多少,我们假设现在要选取的是为最大值,则注意到对于子序列 如果不选,也会和相乘 如果选取,对于所有不是最小值的情况,也会和相乘,而是最小值的情况只有一个(也就是选取和两个) 根据以上的两个推理,我们能够得出,既 时间复杂度 空间复杂度 Code 12345678910class Solution: def sumOfPower(self, nums: List[int]) -&gt; int: mod=1000000007 nums.sort() pre=0 res=0 for num in nums: res=(res+(pre+num)*(num**2))%mod pre=(pre*2+num)%mod return res 12345678910111213class Solution {public: int sumOfPower(vector&lt;int&gt;&amp; nums) { const int mod=1e9+7; sort(nums.begin(),nums.end()); int res=0,pre=0; for (long num:nums){ res=(res+(num*num%mod)*(pre+num))%mod; pre=(pre*2+num)%mod; } return res; }};","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://noirzh.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"Python","slug":"Python","permalink":"https://noirzh.github.io/tags/Python/"},{"name":"数学","slug":"数学","permalink":"https://noirzh.github.io/tags/%E6%95%B0%E5%AD%A6/"}]}],"categories":[],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://noirzh.github.io/tags/markdown/"},{"name":"A=B","slug":"A-B","permalink":"https://noirzh.github.io/tags/A-B/"},{"name":"题解","slug":"题解","permalink":"https://noirzh.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"Python","slug":"Python","permalink":"https://noirzh.github.io/tags/Python/"},{"name":"BFS","slug":"BFS","permalink":"https://noirzh.github.io/tags/BFS/"},{"name":"论文","slug":"论文","permalink":"https://noirzh.github.io/tags/%E8%AE%BA%E6%96%87/"},{"name":"翻译","slug":"翻译","permalink":"https://noirzh.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"动态规划","slug":"动态规划","permalink":"https://noirzh.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"脑筋急转弯","slug":"脑筋急转弯","permalink":"https://noirzh.github.io/tags/%E8%84%91%E7%AD%8B%E6%80%A5%E8%BD%AC%E5%BC%AF/"},{"name":"排序","slug":"排序","permalink":"https://noirzh.github.io/tags/%E6%8E%92%E5%BA%8F/"},{"name":"前缀和","slug":"前缀和","permalink":"https://noirzh.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"数学","slug":"数学","permalink":"https://noirzh.github.io/tags/%E6%95%B0%E5%AD%A6/"}]}