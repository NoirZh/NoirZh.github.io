{"meta":{"title":"一共十七划","subtitle":"","description":"我们逃去看海吧","author":"Noir","url":"http://example.com","root":"/"},"pages":[{"title":"About me","date":"2023-11-11T07:11:59.000Z","updated":"2023-11-11T07:12:50.360Z","comments":true,"path":"about/me.html","permalink":"http://example.com/about/me.html","excerpt":"","text":"代码苦手,审美奇才,希望服务器不会被滥用的产物."},{"title":"书单","date":"2023-11-11T07:21:08.752Z","updated":"2023-11-11T07:21:08.752Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2023-11-11T07:21:08.752Z","updated":"2023-11-11T07:21:08.752Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-11-11T07:21:08.753Z","updated":"2023-11-11T07:21:08.753Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2023-11-11T07:21:08.754Z","updated":"2023-11-11T07:21:08.754Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-11-11T07:21:08.754Z","updated":"2023-11-11T07:21:08.754Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"A=B 第三章题解","slug":"第三章","date":"2023-11-09T15:04:20.000Z","updated":"2023-11-11T08:49:46.752Z","comments":true,"path":"2023/11/09/第三章/","permalink":"http://example.com/2023/11/09/%E7%AC%AC%E4%B8%89%E7%AB%A0/","excerpt":"","text":"前言这个关键字相当于在找到特定的子字符串之后,删去该子字符串,并且将我们指定的新字符串插入到原字符串的开头与结尾 类似于正则表达式的^与$的应用 很像是我们在第二章的操作:将字母压之后换成其他字母往后排以使得压缩持续进行 3-1 去除相当简单的教程 12(start)a=(end)a= 3-2 旋转这里只针对前面不是a进行操作,可以保证 12(start)b=(end)b(start)c=(end)c 3-3 A到B 2思路开始上难度了,但是其实不难,我们只需要先把所有特定位置的a变成特殊的,然后再处理另一边的特殊的即可 就像是我们之前做过的一样,此时的代码如下 123456(start)a=xxa=ax(end)a=zaz=zax=bz=b 优化我们很容易注意到我们的xa&#x3D;ax或者之类的操作只是把所有符合要求的串找出来,保证不阻塞生成 于是我们注意到移到另一边的位置显然更好(指行数更小),更新之后如下 代码1234(start)a=(end)x(end)x=(start)b(end)a=(start)x(start)x=(end)b 3-5 首尾通过上一题我们就知道弄到尾部直接判断即可 我们唯一要注意的就是判断在前,不然容易出死循环 123456789ax=(return)true #有任意一个就是真的,能迅速检查到by=(return)truecz=(return)true#以下的操作会1.在有相同的时候把除了最后一个字母之外都换成其他字母插入到后面 2.没有相同的时候所有都插入到后面(start)a=(end)x(start)b=(end)y(start)c=(end)z=(return)false 3-6 最多 2思路与之前的类似,但是我们需要保留所有作比较的字母来保证恢复,然后这里其实就可以 123456789101112131415ca=accb=bcba=abab=(end)xcx=(end)y #y代表abc,可随时换成最多的 #剩下ac和bc#之后我们不用关心y具体是什么,只要二者消耗,剩下的那个做全员回复就行ac=(end)ybc=(end)y#做一个穷举ax=aacy=ccby=bbay=aabx=bb 优化发现ax,ay的行为是相同的,bx,by也是,优化以下 12345678910111213ca=accb=bcba=abab=(end)xcx=(end)y #y代表abc,可随时换成最多的#acy bcy ay by cy ac=(end)ybc=(end)yx=ycy=ccby=bbay=a 3-7回文串思路判断是不是消除之后全空即可,如3-5的加强版,我们进行全局替换,然后穷举非空情况,但是注意我们不用考虑剩下来的单个字母的情况,因为那种情况也属于回文串 12345678910111213cz=by=ax=(start)a=(end)x(start)b=(end)y(start)c=(end)zxy=(return)falsexz=(return)falseyx=(return)falseyz=(return)falsezx=(return)falsezy=(return)false=(return)true 挑战优化注意到我们六行代码目的都只是为了判断是否有两个字母及以上存在 修改字符串使之存在首尾标识符即可,也就是说能保证显示出来两个字母不同且存在 12345678cuZn=buYn=auXn=(start)a=(end)uXn(start)b=(end)uYn #不影响排空(start)c=(end)uZnnu=(return)false #出现这个说明仍有多个字母存在,整个字符串非空,=(return)true","categories":[],"tags":[{"name":"A=B","slug":"A-B","permalink":"http://example.com/tags/A-B/"}]},{"title":"A=B 第二章题解","slug":"第二章","date":"2023-11-07T07:24:50.000Z","updated":"2023-11-11T08:48:45.921Z","comments":true,"path":"2023/11/07/第二章/","permalink":"http://example.com/2023/11/07/%E7%AC%AC%E4%BA%8C%E7%AB%A0/","excerpt":"","text":"前言我们要好好理解一下a&#x3D;(return)b干了啥: 找到匹配的字符串a 将整个我们的字符串变成b 中断循环,看结果 换成函数表达就是 123if a in s: s=b return s 之后判题的只能看到你返回的字符串b 2.1 你好世界这里给出来了一个提示,在我们用空等的时候 1=(return)helloworld 2.2 AAA思路我们需要看a的数量,也就是说我们不用管b,c,将二者全消除之后剩下的就是a,再看其是否大于等于3个即可 代码1234b=c=aaa=(return)true=(return)false 2.3 恰好三个思路不用管到底是哪个字符,我们只需要验证是不是三个字符即可,所以先把所有字符变成一样的,例如c 接下来我们要判断的不是ccc=(return)true,因为字符串cccc同样包含ccc, 我们首先就排除掉大于3个字符的,其一定包含四个及以上的字符串 这时候对只有三个字符的返回true 剩下的也是false 代码12345a=cb=ccccc=(return)false ccc=(return)true =(return)false 2.4 余数思路这个是return使用的一个示例,所以我们考虑的仍然是只关心字符串长度,不关心内容 将所有都替换成同样的字符 发现求的事余3,我们只需要每次都将三个字符的串放空,剩下的字符串长度就是总长度余3的结果 将长度换成数字 代码这个思路在后续也有用 123456a=cb=c ccc= cc=(return)2c=(return)1=(return)0 2.5 奇数思路划分问题终于开始上难度了,但是这个 思想其实不难理解,我们先做一个简单的想法,我如何判断一长串a是否由奇数组成? 考虑到字符串长度为1&lt;&#x3D;n&lt;&#x3D;7,很容易知道0,1,3,5,7为可能的长度 暴力枚举虽好,但是长度有点太大了,我们可以用另一个方法:奇数减去2之后仍然为奇数 所以我们很容易想到aaa=a来清理串,为什么不能是aa=? 因为这样没有办法确认是刚开始就没有a,还是被偶数a消除掉的 此时长度0,1,2,只有2表示原串是偶数 做法然后我们知道要去做什么了:把三个字符串相同的集中在一起,相当于按顺序再为这三个字符轮流做上述检查操作 所以需要排序,让相同字符待在一起 接下来问题就好解决了 代码12345678910ba=abcb=bcca=acaaa=abbb=bccc=caa=(return)falsebb=(return)falsecc=(return)false=(return)true 进阶你肯定要回来看的,如果你看不懂2.6的话 发现了什么?我们将同样的情况循环了3遍,也就是说,在单独讨论的时候a,b,c其实是等价的,有没有什么办法将它们的等价用代码解释出来? 一个很有趣的想法是将b,c转换成等价a,最后判断三段a是否都满足奇数 一点点魔法:设置一个障碍,让所有相邻相同的字母没有障碍,而让不同的字母之间有障碍 考虑如下代码的运作 12345ba=abcb=bcca=acb=xxaxc=xaxx 这种情况下会发生什么:相邻的b变成了中间隔着3个x的a,不同字母之间隔着2个x 更加显式地能看到假设 bacacc: 123aabccc-&gt; aaxxaxxxaxxxaxxxaxx-&gt; a|a| xxax |xaxx|xaxx|xaxx 仔细观察,发现相隔3个x的都能去掉!,此时会变成用两个x阻隔的三个段,每个段里面的a的个数是a或b或c的个数,此时bacacc变成aaxxaxxaaaxx 然后判断即可 得出来新的代码如下 123456789ba=abcb=bcca=acb=xxaxc=xaxxxxx=aaa=a #等价处理aa=(return)false=(return)true 这种等价思想很重要,在之后会多次使用 其实这种等价想法在于什么:在于让相同字母之间的间隔一样,不同字母的间隔不一样,以这种思路你完全可以设计如下方法: 12345678910111213141516#其中()表示重复几次b=x(n)ax(m)#则c和b之间的距离也应为n,b和b之间距离为m+n#所以c=x(n-m)ax(2m)#符合以上要求的都可以替换#比如以下代码n=6,m=3,一样可以通过ba=abcb=bcca=acb=xxxxxxaxxxc=xxxaxxxxxxxxxxxxxxx=aaa=aaa=(return)false=(return)true 2.6 独一无二思路这里建议先看一下上面的拓展 然后我们先翻译一下题目:希望这个长字符串出现的单字符字符串有且只有一个: aaabccc:只有一个a,是我们需要的 aaabacc:b和a都有,是错误的 实际上我们要做的是在aaa=aa;bbb=bb;ccc=cc之后,看单个的不成对字母有几个 我们只需要知道是不是等于1 和上题拓展法类似,我们等价之后再做类似操作,现在得出来的因为没有排序,我们现在能保证的是 相同字母之间x个数为0或者3 不同字母之间x个数为1或者2 由上述两条我们将串收敛一下,把相等相邻的聚在一块,然后格式一下彼此之间距离 此时出现的就是axaaaxaaxa之类的东西,更进一步地,我们将所有长串都收成空串 此时我们要找的是此时里面是不是只有一个a 看到a就return肯定不行,但是我们能先把多个a存在的删掉,其格式一定为axaxa之类,因为我们上述操作不相同的单字符串串之间一定有一个x阻隔 这时候就有只剩下a的情况了,此时是我们想要的 剩下的情况就是全是长串,也是我们不想要的 代码123456789b=xxaxc=xaxxxxx= #这之后相邻的同字符的串就是相邻的axx=x #此时不同串之间相差1xaaa=aa aa= #两步除长串axa=(return)falsea=(return)true=(return)false 2.7上升思路排序 做之后还会有效的两两对比 先确定是不是c比d多,再确定是不是b比a多 建议先看下面的两个 实现上面的体现 c比b多则b全部化为d,此时还有c剩余 d比a多则a全消失,d还有剩余 也就是说dc存在的时候其实是(bcc)还有剩,合法性足够强 我或许需要一些更加显然的理解,但是现在没有…以后可能试试 12345678ca=accb=bcba=ab #先排序bc=d #合法情况是adcbd=db #此时d代表的是bcad= #消去abc 此时如果合法一定是dcdc=(return)true=(return)false #其他就都不合法 2.8最多思路 对于这种考虑总体字母的,我们先把他们放在一起,先排序 我们考虑到排序,所以我们只要比较三者的多少,很明显能考虑到两两对比 接下来我们最好看代码讲解 代码12345678910111213ca=accb=bcba=ab #先排序bc=d bd=db #此时d代表的是bcad= #消去abc,接下来剩下的就只有一个或两个字母,一定,而且不是bc,把三种组合罗列一下就是结果,只有一个字母显然是答案ac=ab=a=(return)ab=(return)bc=(return)c 2.9最少思路思路与上面的类似 直接看代码吧 123456789101112ca=accb=bcba=ab #先排序ab=ddb=bddc= #销去了abc,可能剩下ad,ac,bc d=(return)c #d存在说明d比c多,也就是ab组合都比c多ac=(return)b bc=(return)a","categories":[],"tags":[{"name":"A=B","slug":"A-B","permalink":"http://example.com/tags/A-B/"}]},{"title":"A=B 第一章题解","slug":"第一章","date":"2023-11-01T13:04:50.000Z","updated":"2023-11-11T08:49:05.676Z","comments":true,"path":"2023/11/01/第一章/","permalink":"http://example.com/2023/11/01/%E7%AC%AC%E4%B8%80%E7%AB%A0/","excerpt":"","text":"前言A&#x3D;B语言也较为特殊,可以认为整体是个循环体,但是是每次循环只要能够执行一条命令就去执行,然后就重新回到循环开头 这个性质会在后续不断应用 而且其本质在做的就是字符串替换 1.1 A到B1a=b 1.2 大写123a=Ab=Bc=C 1.3 去重思路显然我们最后要保留的状态是没有连续字母 只需要将重复的几个压成一个就行,不过要注意A&#x3D;B这个语言的特殊性 代码123aa=abb=bcc=c 1.4 去重 2思路同理,这个是把连续的a压没, 这里之所以会有aaa,而不是直接aa=是因为假如只压缩的可能会剩下来:例如aaa会被替换成a ,我们这么做的本质是将多的字母先压成两个,再把这两个消除掉 12aaa=aaaa= 1.5 排序思路研究语言的必经之路,排序,注意到我们现在在做的是替换字符串 我们的目的是希望各个字母都在其应该在的位置,但我们不知道数组下标,怎么样能达成这两个条件呢? 我们需要一个只看相邻的排序算法,也就是冒泡算法,实现起来不难,如下 代码看到了吗,本质就是大的向后挪动,这个在单步运行时候看的更清楚 123ba=abcb=bcca=ac 这个排序在之后会常用到的,当我们只关心字母数量之类的而不关心其位置的时候 1.6 比较思路比较a和b的多少,还记得去重怎么做的吗?把两个相同的数摁在一起消除 这个题也一样,我们把两个不同的字母摁在一起消除,剩下的就是多的字母 值得一提的是压字母存在两个情况 代码1234ab=ba=aa=abb=b","categories":[],"tags":[{"name":"A=B","slug":"A-B","permalink":"http://example.com/tags/A-B/"}]},{"title":"software","slug":"a_translation","date":"2023-07-01T07:24:50.000Z","updated":"2023-11-11T08:21:49.715Z","comments":true,"path":"2023/07/01/a_translation/","permalink":"http://example.com/2023/07/01/a_translation/","excerpt":"","text":"软件寿命周期模型 结构化和面向对象的建模方法，软件需求分析，软件设计测试，软件维护等 课时安排 工程基础3 需求分析8 软件设计10 实现及测试8 维护及管理3 大作业16 重点及难点 重点 软件生命周期模型 软件需求分析方法 软件设计方法 软件测试 难点 以UML为基础的面向对象建模方法 数据流图方法 黑盒及白盒测试方法4 软件工程绪论计算机软件 什么是软件 IEEE对于软件的定义：软件是计算机程序，规程及运行计算机系统所需要的文档和数据 Wirth指出 在结构化程序设计中程序&#x3D;算法+数据结构 在软件工程里，软件&#x3D;程序+文档 另一种对软件的公认解释是 软件是包括程序，数据及相关文档的完整集合 程序和数据是构造软件的基础，文档是软件质量的保证，也是保证软件更新及生命周期长短的 软件的特点 软件是一种逻辑实体，具有抽象性 软件开发过程中并没有明显的制造过程，应该理解为“创作” 不存在机械磨损和老化问题，但是存在软件退化的问题 软件开发和运行受到计算机系统的约束和限制 直到目前未知软件开发仍未摆脱手工艺的开发方式 软件是复杂的原因 实际需求（业务背景）的复杂性 程序逻辑的复杂性 软件研制成本高，软件成本所占的比例逐年升高 软件投入使用时候涉及到许多社会因素 软件的分类 根据服务对象的范围 通用软件：操作系统，数据库 定制软件：企业ERP，办公自动化系统 根据软件完成功能所处的层次不同 应用软件 中间层软件 系统软件 软件发展和软件危机 软件发展阶段 二十世纪五六十年代：使用者与开发者通常是同一个人， 二十世纪六七十年代开始了程序系统阶段 二十世纪七十到九十年代，开始软件工程阶段 软件危机 1960-1970年的软件快速发展阶段 软件危机的解决： 1968年软件工程大会第一次召开 软件危机 背景：二十世纪六十年代后，随着计算机软件应用领域增多，软件规模不断扩大，软件系统红能多，逻辑复杂，不断扩充，从而导致许多系统开发出现了不同后果 系统存在大量错误，可用性和可靠性差 系统无法增加新功能，南与维护 系统无法按照计划时间完成 系统无法按照计划时间完成 导致很多软件系统彻底失效 所谓软件危机就是计算机软件在开发和维护过程中遇到的一系列严重问题，导致了软件行业的信任危机，具体表现在 软件开发成本难以估算，无法指定合理的开发计划 用户的需求无法确切表达 软件质量存在问题 软件的可维护性差 缺乏文档资料 产生原因 软件系统复杂性 软件开发的方法和技术不合理不成熟 软件工程方法 1968年Friedrich Ludwig Bauer提出运用工程化原则和方法，组织软件开发解决软件危机，并提出软件工程 软件工程 软件工程的定义： Fritz Bauer提出软件工程的概念：软件工程师为了经济地获得能够在十几机器上高效运行的可靠软件而建立和使用的一系列好的工程化原则 Barry Boehm软件工程定义：运用现代科学技术只是来设计并构建计算机程序及未开发，运行和维护这些程序所必须的相关文件资料 ‘Richard E Fairley’认为软件工程学是为了在成本限额以内暗示完成开发和修改软件产品所需要的系统生产和维护的技术和管理的学科 IEEE计算机学会将软件工程定义为： 应用系统化的，规范化的，定量的方法来开发、运行、和维护软件，既将工程应用到软件 对1中的各种方法的研究 软件工程三要素： 方法：提供了如何做的技术 工具：提供了自动或半自动的软件支撑环境 过程：将软件洪城的方法和工具综合起来已达到合理，及时地进行计算机软件开发的目的 软件工程的目标和原则 目标：生产具有正确性，可用性和开销适宜的软件产品 最终目的：摆脱手工产业的方法 软件工程知识体系 软件工程知识体系指南简介 SWEBOK是IEEE主持的一个项目，其目的有五点 促进世界范围内对软件工程的一致观点 阐明软件工程相对其他学科的关系，并划分边界 刻画软件工程学科的内容 提供实用知识体系的主题 设立课程表，行业认证等 软件工程知识体系知识域","categories":[],"tags":[{"name":"test","slug":"test","permalink":"http://example.com/tags/test/"}]}],"categories":[],"tags":[{"name":"A=B","slug":"A-B","permalink":"http://example.com/tags/A-B/"},{"name":"test","slug":"test","permalink":"http://example.com/tags/test/"}]}